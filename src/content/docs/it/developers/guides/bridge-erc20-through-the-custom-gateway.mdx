---
section: developers
date: Last Modified
title: "Bridge di un Token ERC20 tramite un Gateway Personalizzato"
lang: "it"
permalink: "developers/guides/bridge-erc20-through-the-custom-gateway"
whatsnext: { "Running a Scroll Node": "/it/developers/guides/running-a-scroll-node" }
excerpt: "This guide will walk through how to use Scroll's bridge for ERC20s that need custom functionality using the Custom Gateway."
---

import Aside from "../../../../../components/Aside.astro"

Questa guida ti condurrà attraverso l'uso del bridge di Scroll per gli ERC20 che necessitano di funzionalità personalizzate utilizzando il Custom Gateway.

<Aside type="tip" title="Hai bisogno di logica personalizzata?">
  Ricorda, per molti contesti, non è necessario utilizzare il Custom Gateway per aggiungere funzionalità aggiuntive al tuo token o alla sua logica di bridge. Consulta l'articolo su [ETH and ERC20 Token Bridge](/developers/l1-and-l2-bridging/eth-and-erc20-token-bridge#deposit-eth-and-erc20-tokens-from-l1) per maggiori informazioni.
</Aside>

## Passo 1: Lanciare un token su Sepolia

Prima di tutto, abbiamo bisogno di un token da bridge. Non è necessario un'implementazione particolare di ERC20 affinché un token sia compatibile con L2. Se possiedi già un token, puoi saltare questo passaggio. Se desideri deployare un nuovo token, utilizza il seguente contratto di un semplice token ERC20 che emette 1 milione di token al deployer al momento del lancio.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract L1Token is ERC20 {
  constructor() ERC20("My Token L1", "MTL1") {
    _mint(msg.sender, 1_000_000 ether);
  }
}
```

## Passo 2: Lanciare il token controparte su Scroll Sepolia testnet

Successivamente, lancerai una controparte di questo token su Scroll, che rappresenterà il token originale su Sepolia. Questo token può implementare logiche personalizzate per corrispondere a quelle del token L1 o aggiungere funzionalità aggiuntive oltre a quelle del token L1.

Per far funzionare questo processo:

- Il token deve implementare l'interfaccia `IScrollStandardERC20` per essere compatibile con il bridge.
- Il contratto deve fornire l'indirizzo del gateway e l'indirizzo del token controparte (il token L1 che abbiamo appena lanciato) tramite le funzioni `gateway()` e `counterpart()`. Deve anche consentire al gateway L2 di chiamare le funzioni `mint()` e `burn()` del token, che vengono chiamate durante il deposito e il prelievo del token.

Di seguito è riportato un esempio completo di un token compatibile con il bridge. Al costruttore, passerai l'indirizzo ufficiale del Scroll Custom Gateway (`0x058dec71E53079F9ED053F3a0bBca877F6f3eAcf`) e l'indirizzo del token lanciato su Sepolia.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@scroll-tech/contracts@0.1.0/libraries/token/IScrollERC20Extension.sol";

contract L2Token is ERC20, IScrollERC20Extension {
  // We store the gateway and the L1 token address to provide the gateway() and counterpart() functions which are needed from the Scroll Standard ERC20 interface
  address _gateway;
  address _counterpart;

  // In the constructor we pass as parameter the Custom L2 Gateway and the L1 token address as parameters
  constructor(address gateway_, address counterpart_) ERC20("My Token L2", "MTL2") {
    _gateway = gateway_;
    _counterpart = counterpart_;
  }

  function gateway() public view returns (address) {
    return _gateway;
  }

  function counterpart() external view returns (address) {
    return _counterpart;
  }

  // We allow minting only to the Gateway so it can mint new tokens when bridged from L1
  function transferAndCall(address receiver, uint256 amount, bytes calldata data) external returns (bool success) {
    transfer(receiver, amount);
    data;
    return true;
  }

  // We allow minting only to the Gateway so it can mint new tokens when bridged from L1
  function mint(address _to, uint256 _amount) external onlyGateway {
    _mint(_to, _amount);
  }

  // Similarly to minting, the Gateway is able to burn tokens when bridged from L2 to L1
  function burn(address _from, uint256 _amount) external onlyGateway {
    _burn(_from, _amount);
  }

  modifier onlyGateway() {
    require(gateway() == _msgSender(), "Ownable: caller is not the gateway");
    _;
  }
}
```
## Passo 3: Aggiungi il token al Scroll Bridge

È necessario contattare il team di Scroll per aggiungere il token al contratto `L2CustomERC20Gateway` su Scroll e al contratto `L1CustomERC20Gateway` su L1. Segui anche le istruzioni nel repository delle [liste dei token](https://github.com/scroll-tech/token-list) per aggiungere il tuo token all'interfaccia ufficiale del bridge di Scroll.

## Passo 4: Deposito dei token

Una volta che il tuo token è stato approvato dal team di Scroll, dovresti essere in grado di depositare i token da L1. Per farlo, devi prima approvare l'indirizzo del contratto `L1CustomGateway` su Sepolia (`0x31C994F2017E71b82fd4D8118F140c81215bbb37`). Quindi, deposita i token chiamando la funzione `depositERC20` dal contratto `L1CustomGateway`. Questo può essere fatto utilizzando [la nostra interfaccia del bridge](https://scroll.io/bridge), [Etherscan Sepolia](https://sepolia.etherscan.io/address/0x31C994F2017E71b82fd4D8118F140c81215bbb37#writeProxyContract) o un contratto intelligente.

## Passo 5: Prelievo dei token

Seguirai passaggi simili per inviare i token da L2 a L1. Prima, approva l'indirizzo del contratto `L2CustomGateway` (`0x058dec71E53079F9ED053F3a0bBca877F6f3eAcf`) e quindi preleva i token chiamando la funzione `withdrawERC20` dal contratto `L2CustomGateway`.

## Approccio Alternativo: Lancio e configurazione di un contratto gateway L1 personalizzato

Aggiungere il tuo token al bridge ufficiale di Scroll (come descritto sopra) è il metodo consigliato per collegare i token da e verso Scroll. Questo approccio renderà i token più facili da scoprire e più sicuri per i titolari. Tuttavia, richiederà l'approvazione dal team di Scroll. Se desideri lanciare un token personalizzato senza il processo di approvazione ufficiale, puoi lanciare tu stesso un gateway personalizzato. Per farlo, dovrai implementare un contratto `L1CustomERC20Gateway` su L1 e un `L2CustomERC20Gateway` su L2.

### Lancio di un Gateway Personalizzato su L1

Iniziamo con il lancio del seguente contratto su Sepolia.


```solidity
// SPDX-License-Identifier: MIT

// Although it's possible to use other Solidity versions, we recommend using version 0.8.16 because that's where our contracts were audited
pragma solidity =0.8.16;

import "@openzeppelin/contracts/access/Ownable.sol";

import { IL2ERC20Gateway } from "@scroll-tech/contracts@0.1.0/L2/gateways/IL2ERC20Gateway.sol";
import { IL1ScrollMessenger } from "@scroll-tech/contracts@0.1.0/L1/IL1ScrollMessenger.sol";
import { IL1ERC20Gateway } from "@scroll-tech/contracts@0.1.0/L1/gateways/IL1ERC20Gateway.sol";

import { ScrollGatewayBase } from "@scroll-tech/contracts@0.1.0/libraries/gateway/ScrollGatewayBase.sol";
import { L1ERC20Gateway } from "@scroll-tech/contracts@0.1.0/L1/gateways/L1ERC20Gateway.sol";

// This contract will be used to send and receive tokens from L2
contract L1CustomERC20Gateway is L1ERC20Gateway, Ownable {
  // Tokens must be mapped to "bind" them to a token that represents the original token on the original. This event will be emitted when the token mapping for ERC20 token is updated.
  event UpdateTokenMapping(address indexed l1Token, address indexed oldL2Token, address indexed newL2Token);

  mapping(address => address) public tokenMapping;

  constructor() {}

  // This function must be called once after both the L1 and L2 contract was deployed
  function initialize(address _counterpart, address _router, address _messenger) external {
    require(_router != address(0), "zero router address");

    ScrollGatewayBase._initialize(_counterpart, _router, _messenger);
  }

  /// This function returns the address of the token on L2
  function getL2ERC20Address(address _l1Token) public view override returns (address) {
    return tokenMapping[_l1Token];
  }

  // Updates the token mapping that "binds" a token with another one on the other chain
  function updateTokenMapping(address _l1Token, address _l2Token) external onlyOwner {
    require(_l2Token != address(0), "token address cannot be 0");

    address _oldL2Token = tokenMapping[_l1Token];
    tokenMapping[_l1Token] = _l2Token;

    emit UpdateTokenMapping(_l1Token, _oldL2Token, _l2Token);
  }

  // Callback called before a token is withdrawn on L1
  function _beforeFinalizeWithdrawERC20(
    address _l1Token,
    address _l2Token,
    address,
    address,
    uint256,
    bytes calldata
  ) internal virtual override {
    require(msg.value == 0, "nonzero msg.value");
    require(_l2Token != address(0), "token address cannot be 0");
    require(_l2Token == tokenMapping[_l1Token], "l2 token mismatch");
  }

  // Token bridged can be "canceled" or dropped. This callback is called before that happens.
  function _beforeDropMessage(address, address, uint256) internal virtual override {
    require(msg.value == 0, "nonzero msg.value");
  }

  // Internal function holding the deposit logic
  function _deposit(
    address _token,
    address _to,
    uint256 _amount,
    bytes memory _data,
    uint256 _gasLimit
  ) internal virtual override nonReentrant {
    address _l2Token = tokenMapping[_token];
    require(_l2Token != address(0), "no corresponding l2 token");

    // 1. Transfer token into this contract.
    address _from;
    (_from, _amount, _data) = _transferERC20In(_token, _amount, _data);

    // 2. Generate message passed to L2CustomERC20Gateway.
    bytes memory _message = abi.encodeCall(
      IL2ERC20Gateway.finalizeDepositERC20,
      (_token, _l2Token, _from, _to, _amount, _data)
    );

    // 3. Send message to L1ScrollMessenger.
    IL1ScrollMessenger(messenger).sendMessage{ value: msg.value }(counterpart, 0, _message, _gasLimit, _from);

    emit DepositERC20(_token, _l2Token, _from, _to, _amount, _data);
  }
}
```
### Lancio di un Gateway Personalizzato su L2

Ora procediamo con il lancio del contratto corrispondente su Scroll.


```solidity
// SPDX-License-Identifier: MIT

pragma solidity =0.8.16;

import "@openzeppelin/contracts/access/Ownable.sol";

import "@scroll-tech/contracts@0.1.0/L2/gateways/L2ERC20Gateway.sol";
import { IL2ScrollMessenger } from "@scroll-tech/contracts@0.1.0/L2/IL2ScrollMessenger.sol";
import { IL1ERC20Gateway } from "@scroll-tech/contracts@0.1.0/L1/gateways/IL1ERC20Gateway.sol";
import { ScrollGatewayBase } from "@scroll-tech/contracts@0.1.0/libraries/gateway/ScrollGatewayBase.sol";
import "@scroll-tech/contracts@0.1.0/libraries/token/IScrollERC20Extension.sol";

import { IL2ERC20Gateway } from "@scroll-tech/contracts@0.1.0/L2/gateways/IL2ERC20Gateway.sol";

// This contract will be used to send and receive tokens from L1
contract L2CustomERC20Gateway is L2ERC20Gateway, ScrollGatewayBase, Ownable {
  event UpdateTokenMapping(address indexed l2Token, address indexed oldL1Token, address indexed newL1Token);

  // solhint-disable-next-line var-name-mixedcase
  mapping(address => address) public tokenMapping;

  constructor() {}

  // Like with the L1 version of the Gateway, this must be called once after both the L1 and L2 gateways are deployed
  function initialize(address _counterpart, address _router, address _messenger) external {
    require(_router != address(0), "zero router address");

    ScrollGatewayBase._initialize(_counterpart, _router, _messenger);
  }

  /// Returns the address of the token representing the token on L2
  function getL1ERC20Address(address _l2Token) external view override returns (address) {
    return tokenMapping[_l2Token];
  }

  // This returns the L2 token address
  function getL2ERC20Address(address) public pure override returns (address) {
    revert("unimplemented");
  }

  // This function finalizes the token deposit on L2 when the deposit was not finalized due to not enough gas sent from L1
  function finalizeDepositERC20(
    address _l1Token,
    address _l2Token,
    address _from,
    address _to,
    uint256 _amount,
    bytes calldata _data
  ) external payable override onlyCallByCounterpart nonReentrant {
    require(msg.value == 0, "nonzero msg.value");
    require(_l1Token != address(0), "token address cannot be 0");
    require(_l1Token == tokenMapping[_l2Token], "l1 token mismatch");

    IScrollERC20Extension(_l2Token).mint(_to, _amount);

    _doCallback(_to, _data);

    emit FinalizeDepositERC20(_l1Token, _l2Token, _from, _to, _amount, _data);
  }

  // Same as in the L1 version of this contract, this function "binds" a token with a token on the other chain
  function updateTokenMapping(address _l2Token, address _l1Token) external onlyOwner {
    require(_l1Token != address(0), "token address cannot be 0");

    address _oldL1Token = tokenMapping[_l2Token];
    tokenMapping[_l2Token] = _l1Token;

    emit UpdateTokenMapping(_l2Token, _oldL1Token, _l1Token);
  }

  // Internal function holding the withdraw logic
  function _withdraw(
    address _token,
    address _to,
    uint256 _amount,
    bytes memory _data,
    uint256 _gasLimit
  ) internal virtual override nonReentrant {
    address _l1Token = tokenMapping[_token];
    require(_l1Token != address(0), "no corresponding l1 token");

    require(_amount > 0, "withdraw zero amount");

    // 1. Extract real sender if this call is from L2GatewayRouter.
    address _from = msg.sender;
    if (router == msg.sender) {
      (_from, _data) = abi.decode(_data, (address, bytes));
    }

    // 2. Burn token.
    IScrollERC20Extension(_token).burn(_from, _amount);

    // 3. Generate message passed to L1StandardERC20Gateway.
    bytes memory _message = abi.encodeCall(
      IL1ERC20Gateway.finalizeWithdrawERC20,
      (_l1Token, _token, _from, _to, _amount, _data)
    );

    // 4. send message to L2ScrollMessenger
    IL2ScrollMessenger(messenger).sendMessage{ value: msg.value }(counterpart, 0, _message, _gasLimit);

    emit WithdrawERC20(_l1Token, _token, _from, _to, _amount, _data);
  }
}
```
### Configura il tuo Contratto Gateway su Sepolia

Una volta che i contratti sono stati deployati, chiama le seguenti funzioni per inizializzare i contratti e collegarli ai token corrispondenti e al gateway sull'altro lato del bridge.

Innanzitutto, chiama la funzione `initialize` sul contratto `MyL1Gateway` con i seguenti parametri:

- `_counterpart`: L'indirizzo di `MyL2Gateway` che abbiamo appena lanciato su Scroll.
- `_router`: Impostalo su `0x13FBE0D0e5552b8c9c4AE9e2435F38f37355998a`, il contratto `L1GatewayRouter` su Sepolia.
- `_messenger`: Impostalo su `0x50c7d3e7f7c656493D1D76aaa1a836CedfCBB16A`, il contratto `L1ScrollMessenger` su Sepolia.

Un gateway personalizzato può ospitare più bridge token. In questo caso, permetteremo solo il bridging tra L1Token e L2Token chiamando la funzione `updateTokenMapping` sul contratto `MyL1Gateway` con i seguenti parametri:

- `_l1Token`: L'indirizzo del contratto `L1Token` che abbiamo precedentemente lanciato su Sepolia.
- `_l2Token`: L'indirizzo del contratto `L2Token` che abbiamo precedentemente lanciato su Scroll.

### Configura il tuo Contratto Gateway su Scroll

Passiamo ora alla chain di Scroll e inizializziamo `MyL2Gateway`, seguendo passi simili.

Innanzitutto, chiama la funzione `initialize` da `MyL2Gateway`:

- `_counterpart`: L'indirizzo di `MyL1Gateway` che abbiamo appena lanciato su Sepolia.
- `_router`: Impostalo su `0x9aD3c5617eCAa556d6E166787A97081907171230`, il contratto `L2GatewayRouter` su Scroll.
- `_messenger`: Impostalo su `0xBa50f5340FB9F3Bd074bD638c9BE13eCB36E603d`, il contratto `L2ScrollMessenger` su Scroll.

Successivamente, chiama `updateTokenMapping` sul contratto `MyL2Gateway`:

- `_l2Token`: L'indirizzo del contratto `L2Token` che abbiamo precedentemente lanciato su Scroll.
- `_l1Token`: L'indirizzo del contratto `L1Token` che abbiamo precedentemente lanciato su Sepolia.

### Bridging dei token

Ora possiamo chiamare `depositERC20` da `MyL1Gateway` e `withdrawERC20` da `MyL2Gateway` proprio come con il bridge ufficiale di Scroll.
