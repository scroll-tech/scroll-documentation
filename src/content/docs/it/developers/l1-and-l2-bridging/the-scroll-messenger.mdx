---
section: developers
date: Last Modified
title: "Il Messaggero di Scroll"
lang: "it"
permalink: "developers/l1-and-l2-bridging/the-scroll-messenger"
whatsnext: { "Commissioni di Transazione su Scroll": "/it/developers/transaction-fees-on-scroll/" }
excerpt: "The Scroll Messenger documentation for arbitrary message passing between L1 and L2."
---
import Aside from "../../../../../components/Aside.astro"

I contratti Scroll Messenger consentono di inviare messaggi arbitrari da L1 a L2 o viceversa. Ciò consente di eseguire funzioni su un'altra chain in modo sicuro e senza autorizzazioni. Per inviare un messaggio da L1 a L2, utilizzare il contratto smart messenger deployato su L1, `L1ScrollMessenger`. Per inviare un messaggio da L2 a L1, utilizzare il contratto deployato su L2, `L2ScrollMessenger`.

<Aside type="caution" title="">
  Quando si invia una transazione tramite **Scroll Messenger** deployato su L1 e L2, il mittente della transazione risultante
  (`CALLER` o `msg.sender`) sarà l'indirizzo del contratto Messenger deployato sulla chain ricevente.
  <br />
  Nelle future versioni di Scroll, le transazioni forzate da L1 permetteranno di impostare il mittente su L2 come l'EOA originale
  su L1. Consentirà anche a terze parti di inoltrare transazioni firmate in modo sicuro.
</Aside>

## Finalizzare transazioni su L1

Qualsiasi transazione imminente da L2 deve essere finalizzata utilizzando la funzione `relayMessageWithProof` sul contratto Scroll Messenger.
Chiamiamo questo processo "invio di una transazione di esecuzione del prelievo," ed è necessario sia per inviare messaggi arbitrari che per trasferire asset tramite un gateway o il router. Quando si utilizza `relayMessageWithProof`, è necessario fornire una prova di inclusione di Merkle che mostri che la tua transazione è inclusa nel trie dei messaggi di "withdrawal," insieme ad altri parametri. La produzione di questa prova e di questi valori può essere fatta localmente e senza autorizzazioni, ma al momento il modo più semplice per ottenere questi parametri è attraverso le nostre API di backend:

- Scroll Sepolia API: https://sepolia-api-bridge-v2.scroll.io/api/
- Scroll API: https://mainnet-api-bridge-v2.scroll.io/api/

<Aside type="danger" title="API Sperimentale">
  Questa API è stata creata per la nostra interfaccia Bridge UI. Non è ancora finalizzata e potrebbe cambiare in futuro. Aggiorneremo questa guida
  quando l'API sarà finalizzata. Inoltre, tutti gli esempi di seguito utilizzano il servizio API Sepolia -- le chiamate possono essere facilmente
  adattate per funzionare sulla mainnet.
</Aside>

Fornire l'indirizzo dell'EOA o del contratto responsabile per l'inizializzazione della transazione originale su L2 al endpoint `/claimable`.
Il backend API ti fornirà tutte le informazioni necessarie per concludere con successo la transazione su L1.
Guarda l'esempio seguente:


```bash
https://sepolia-api-bridge.scroll.io/api/claimable?address=0x031407eaaffFB4f1EC2c999bE4477E52C81de3c5&page_size=10&page=1
```

Le API dovrebbe restituire i dati della tua transazione nel seguente formato:

```json
{
  "errcode": 0,
  "errmsg": "",
  "data": {
    "result": [
      {
        "hash": "0xa476850306d6ee52b127628ded34dcf2343570873cce9c5383bd497db48d4f9b",
        "amount": "",
        "to": "",
        "isL1": false,
        "l1Token": "",
        "l2Token": "",
        "blockNumber": 748,
        "blockTimestamp": null,
        "finalizeTx": {
          "hash": "",
          "amount": "",
          "to": "",
          "isL1": false,
          "blockNumber": 0,
          "blockTimestamp": null
        },
        "claimInfo": {
          "from": "0x031407eaaffFB4f1EC2c999bE4477E52C81de3c5",
          "to": "0x1039057185CFe192d16c03F5656225821A193FD5",
          "value": "0",
          "nonce": "9",
          "batch_hash": "0x49a18d72dbceeb957f918947b532db452c031f528e7e6bf329007066638c5e50",
          "message": "0xa413686200000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000005686f6c6973000000000000000000000000000000000000000000000000000000",
          "proof": "0x69b4ee6cf9a38bed79668ddd347fef2bdff44c3760c9309fa41decfd60202d22ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d3079f53171df5c0661d2afe86c4d97b6f34278daf6a0ea9baff5b4fc979d5629a5",
          "batch_index": "93"
        },
        "createdTime": null
      }
    ],
    "total": 1
  }
}
```

L' oggetto `claimInfo` nel json restituito sotto `result` contiene tutte le informazioni necessarie per eseguire la tua transazione su L1. I parametri richiesti dalla funzione `relayMessageWithProof` sono: `from`, `to`, `value`, `nonce`, `message` e `proof`. Fornisci questi parametri alla funzione `relayMessageWithProof` su L1 per eseguire e finalizzare la tua transazione su L1.

<Aside type="tip" title="">
  Tutte le transazioni su L2 sono raggruppate in batch: è necessario attendere che il batch che include la tua transazione sia finalizzato prima di chiamare `relayMessageWithProof`. L'indice del batch della tua transazione è restituito nel valore `batch_index` sull'endpoint `/claimable`, e puoi seguire il progresso sull'[esploratore di Scroll Rollup](https://scroll.io/rollupscan?page=1&per_page=10).
</Aside>

## API del Messenger

Consulta la [libreria npm](https://www.npmjs.com/package/@scroll-tech/contracts?activeTab=code) per la documentazione completa dell'API dei contratti di Scroll.

### sendMessage


```solidity
function sendMessage(
  address target,
  uint256 value,
  bytes calldata message,
  uint256 gasLimit,
  address refundAddress
) external payable;
```

Invia dati arbitrari da una chain a un'altra. Permette l'esecuzione di funzioni tra chains.

| Parametro      | Descrizione                                                                                                          |
| -------------- | -------------------------------------------------------------------------------------------------------------------- |
| target         | L'indirizzo dell'account che riceve il messaggio. Il destinatario può essere un contratto intelligente o un portafoglio EOA. |
| value          | La quantità di ether passata durante la chiamata al contratto di destinazione.                                       |
| message        | Il contenuto del messaggio. Questo è il calldata arbitrario da eseguire.                                              |
| gasLimit       | Limite di gas richiesto per completare il relay del messaggio sulla chain corrispondente.                           |
| refundAddress  | L'indirizzo dell'account che riceverà il rimborso della commissione.                                                  |
### relayMessageWithProof

```solidity
function relayMessageWithProof(
  address from,
  address to,
  uint256 value,
  uint256 nonce,
  bytes memory message,
  L2MessageProof memory proof
) external;
```
Relay di un messaggio da L2 a L1 con prova del messaggio.

| Parametro | Descrizione                                                   |
| --------- | ------------------------------------------------------------- |
| from      | L'indirizzo del mittente del messaggio.                        |
| to        | L'indirizzo del destinatario del messaggio.                    |
| value     | Il valore `msg.value` passato alla chiamata del messaggio.     |
| nonce     | Il nonce del messaggio per evitare attacchi di replay.         |
| message   | Il contenuto del messaggio.                                    |
| proof     | La prova utilizzata per verificare la correttezza della transazione. |
