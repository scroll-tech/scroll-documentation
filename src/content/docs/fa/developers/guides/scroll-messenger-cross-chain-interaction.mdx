---
section: developers  
date: Last Modified  
title: "تعامل میان زنجیره‌ای Scroll Messenger"  
lang: "fa"  
permalink: "developers/guides/scroll-messenger-cross-chain-interaction"  
whatsnext: { "بریج ERC20 از طریق درگاه سفارشی": "/fa/developers/guides/bridge-erc20-through-the-custom-gateway" }  
excerpt: "در این مثال، ما یک قرارداد هوشمند نمونه را در شبکه آزمایشی Sepolia یا Scroll مستقر خواهیم کرد و با آن از زنجیره مخالف تعامل خواهیم کرد."  
---

import Aside from "../../../../../components/Aside.astro"  

در این مثال، ما یک قرارداد هوشمند نمونه را در شبکه آزمایشی Sepolia یا Scroll مستقر خواهیم کرد و با آن از زنجیره مخالف تعامل خواهیم کرد. ما از `ScrollMessenger` استفاده خواهیم کرد که بر روی هر دو شبکه Sepolia و Scroll مستقر شده است.

## استقرار قراردادها

### قرارداد هوشمند هدف

ابتدا با استقرار قرارداد هوشمند هدف شروع می‌کنیم. برای این مثال، از قرارداد Greeter استفاده خواهیم کرد، اما می‌توانید از هر قرارداد دیگری استفاده کنید. آن را به Sepolia یا Scroll مستقر کنید. در Scroll، L1 و L2 از یک API مشابه استفاده می‌کنند، بنابراین انتخاب با شماست.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;

// این قرارداد Greeter از طریق ScrollMessenger در سراسر بریج با آن تعامل خواهد شد
contract Greeter {
  string public greeting = "Hello World!";

  // این تابع توسط executeFunctionCrosschain در قرارداد Operator صدا زده خواهد شد
  function setGreeting(string memory greeting_) public {
    greeting = greeting_;
  }
}
```

اکنون، تابع `setGreeting` را به صورت میان زنجیره‌ای اجرا خواهیم کرد.

### قرارداد هوشمند Operator

به زنجیره دیگر بروید و `GreeterOperator` را مستقر کنید. بنابراین، اگر قرارداد `Greeter` را در L1 مستقر کردید، قرارداد `GreeterOperator` را در L2 یا برعکس مستقر کنید.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;

// رابط Scroll Messenger در هر دو L1 و L2 مشابه است و اجازه ارسال تراکنش‌های میان زنجیره‌ای را می‌دهد
// بیایید مستقیماً از کتابخانه قراردادهای Scroll آن را وارد کنیم
import "@scroll-tech/contracts@0.1.0/libraries/IScrollMessenger.sol";

// GreeterOperator قادر به اجرای تابع Greeter از طریق بریج است
contract GreeterOperator {
  // این تابع setGreeting را در قرارداد Greeter اجرا خواهد کرد
  function executeFunctionCrosschain(
    address scrollMessengerAddress,
    address targetAddress,
    uint256 value,
    string memory greeting,
    uint32 gasLimit
  ) public payable {
    IScrollMessenger scrollMessenger = IScrollMessenger(scrollMessengerAddress);
    // sendMessage قادر است هر تابعی را با کدگذاری ABI با استفاده از تابع encodeWithSignature اجرا کند
    scrollMessenger.sendMessage{ value: msg.value }(
      targetAddress,
      value,
      abi.encodeWithSignature("setGreeting(string)", greeting),
      gasLimit,
      msg.sender
    );
  }
}
```

## فراخوانی تابع میان زنجیره‌ای

ما با اجرای `executeFunctionCrosschain` و ارسال پارامترهای زیر، پیام را منتقل می‌کنیم:

- `scrollMessengerAddress`: این بستگی به جایی که قرارداد `GreeterOperator` را مستقر کرده‌اید دارد.
  - اگر آن را در Sepolia مستقر کردید از `0x50c7d3e7f7c656493D1D76aaa1a836CedfCBB16A` استفاده کنید. اگر در Scroll Sepolia مستقر کردید از `0xBa50f5340FB9F3Bd074bD638c9BE13eCB36E603d` استفاده کنید.
- `targetAddress`: آدرس قرارداد `Greeter` در زنجیره مخالف.
- `value`: در این مورد، `0` است زیرا تابع `setGreeting` پرداختی ندارد.
- `greeting`: این پارامتر است که از طریق پیام ارسال خواهد شد. سعی کنید `“این پیام میان زنجیره‌ای بود!”` را ارسال کنید.
- `gasLimit`:
  - اگر پیام را از L1 به L2 ارسال می‌کنید، حدود `1000000` محدودیت گس باید کافی باشد. به گفته‌ی دیگر، اگر این مقدار را خیلی بالا تنظیم کنید و `msg.value` نتواند `gasLimit` * `baseFee` را پوشش دهد، تراکنش برگشت خواهد خورد. اگر `msg.value` بیشتر از هزینه گس باشد، مقدار باقی‌مانده پس داده خواهد شد.
  - اگر پیام را از L2 به L1 ارسال می‌کنید، `0` را ارسال کنید، زیرا تراکنش با اجرای یک تراکنش اضافی در L1 تکمیل خواهد شد.

### انتقال پیام هنگام ارسال از L2 به L1

هنگامی که تراکنش از L2 به L1 منتقل می‌شود، یک تراکنش اضافی "اجرا کردن برداشت" باید در L1 ارسال شود. برای این کار، باید تابع `relayMessageWithProof` را از یک کیف پول EOA بر روی قرارداد Scroll Messenger در L1 فراخوانی کنید.

شما می‌توانید این کار را به طور مستقیم بر روی [Etherscan Sepolia](https://sepolia.etherscan.io/address/0x50c7d3e7f7c656493d1d76aaa1a836cedfcbb16a#writeProxyContract#F3) انجام دهید.
برای انجام این کار، شما باید یک اثبات گنجاندن Merkle برای تراکنش بریج‌شده و سایر پارامترها را ارسال کنید. این‌ها را با استفاده از API بریج Scroll جستجو خواهید کرد.

{/* TODO: finish looking into API issues */}

ما در حال نهایی کردن جزئیات API هستیم، اما در حال حاضر، می‌توانید با استفاده از curl یا fetch به نقطه پایانی زیر دسترسی پیدا کنید:

```bash
curl "https://sepolia-api-bridge.scroll.io/api/claimable?page_size=10&page=1&address=GREETER_OPERATOR_ADDRESS_ON_L2"
```

آدرس `GREETER_OPERATOR_ADDRESS_ON_L2` را با آدرس قرارداد GreeterOperator خود در L2 جایگزین کنید. درباره تراکنش‌های اجرای برداشت بیشتر بخوانید در مقاله [Scroll Messenger](/developers/l1-and-l2-bridging/the-scroll-messenger).

<Aside type="danger" title="API تجربی">
  این API برای رابط کاربری بریج ما ساخته شده است. هنوز نهایی نشده و ممکن است در آینده تغییر کند. ما این راهنما را هنگامی که API نهایی شد به‌روزرسانی خواهیم کرد.
</Aside>

<Aside type="caution" title="هر کسی می‌تواند پیام L2 → L1 شما را اجرا کند">
  `relayMessageWithProof` به طور کامل بدون مجوز است، بنابراین هر کسی می‌تواند آن را به نمایندگی از شما اجرا کند اگر حاضر به پرداخت هزینه‌های گس L1 باشد. این ویژگی اجازه می‌دهد زیرساخت‌های پشتیبانی اضافی، از جمله ابزارهایی برای خودکارسازی این فرآیند برای برنامه‌ها و کاربران.
</Aside>

پس از اجرای و تأیید تراکنش در هر دو L1 و L2، وضعیت جدید `greeting` در قرارداد `Greeter` باید `“این پیام میان زنجیره‌ای بود!”` باشد. ارسال پیام از یک زنجیره به زنجیره دیگر باید حدود 20 دقیقه پس از تأیید تراکنش‌ها در زنجیره مبدأ طول بکشد.

تبریک می‌گوییم، شما اکنون یک تراکنش را از یک زنجیره به زنجیره دیگر با استفاده از بریج بومی ما اجرا کرده‌اید!

