---
section: technology
date: Last Modified
title: "بررسی اجمالی zkEVM"
lang: "fa"
permalink: "technology/zkevm-overview"
excerpt: "برای درک نحوه ساخت یک zkEVM که اجرای EVM را اثبات می‌کند، ابتدا باید به خود EVM نگاه کنیم."
---

import ClickToZoom from "../../../../../components/ClickToZoom.astro"
import zkevm1 from "../_images/zkevm1.png"
import zkevm2 from "../_images/zkevm2.png"
import zkevm3 from "../_images/zkevm3.png"

## EVM چیست؟

برای درک نحوه ساخت یک zkEVM که اجرای EVM را اثبات می‌کند، ابتدا باید به خود EVM نگاه کنیم.

EVM می‌تواند به عنوان یک تابع تغییر وضعیت مدل‌سازی شود. این تابع تغییر وضعیت `f` را مشخص می‌کند که، با توجه به وضعیت اولیه جهانی `S` و یک تراکنش `T`، وضعیت جهانی جدید `S'` را خروجی می‌دهد: `f(S,T) = S'`.

"وضعیت جهانی" به عنوان یک [پریتیچایز-مرکل درخت](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/) (MPT) مدل‌سازی می‌شود. این درخت شامل تمام داده‌های پایدار شبکه است. این شامل اطلاعات تمام حساب‌های خارجی (EOAs) و حساب‌های قراردادهای هوشمند است. حساب‌های قرارداد هوشمند دارای زیر درخت‌هایی هستند که کد بایت و ذخیره‌سازی پایدار قرارداد هوشمند را نگه می‌دارند.

EVM یک تراکنش جدید را با اجرای محاسبات آن و انجام تغییرات مربوطه در وضعیت جهانی پردازش می‌کند. محاسبات EVM بر روی داده‌های موقت (پشته و حافظه) و همچنین داده‌های پایدار (کد بایت و ذخیره‌سازی قرارداد) انجام می‌شود.

<ClickToZoom src={zkevm1} />

محاسبات تحریک شده توسط یک تراکنش فردی به دستورات ماشینی کوچکی به نام "opcodes" تقسیم می‌شود که EVM می‌تواند به طور مستقیم آنها را درک و اجرا کند. رفتار هر opcode در [کاغذ زرد اتریوم](https://ethereum.github.io/yellowpaper/paper.pdf) مشخص شده است. اجرای یک تراکنش بنابراین می‌تواند با یک "ردیف اجرای" خلاصه شود، که به سادگی یک لیست مرتب از اجرای opcodes است. کلاینت‌های اجرایی اتریوم، مانند [Geth](https://geth.ethereum.org/)، می‌توانند به وضوح یک ردیف اجرای مرحله به مرحله را برای محاسباتی که انجام داده‌اند، تولید کنند.

<ClickToZoom src={zkevm2} />

با اجرای opcodes، درخت وضعیت تغییر می‌کند. این منجر به یک درخت وضعیت جدید با یک ریشه وضعیت جدید می‌شود.

## اثبات اجرای EVM

هدف از zkEVM تولید یک اثبات است که به درستی اجرای یک تراکنش را تأیید کند. به عبارت دیگر، با توجه به وضعیت جهانی اولیه `S`، یک تراکنش `T`، و وضعیت جهانی نتیجه‌گیری شده `S'`، zkEVM باید اثباتی تولید کند که `f(S,T) = S'`، جایی که `f` تابع تغییر وضعیت مشخص شده در کاغذ زرد اتریوم است.

برای اثبات صحت اجرای تابع تغییر وضعیت، اجرای آن به ردیف اجرای مرحله به مرحله خود تقسیم می‌شود. اجرای `f(S,T)` به لیستی از اجرای‌های متوالی opcodes گسترش می‌یابد. ردیف اجرای به عنوان یک "شاهد" که صحت تغییر وضعیت `f(S,T) = S'` را تأیید می‌کند، عمل می‌کند - این ردیف به نوعی توضیح مرحله به مرحله از نحوه تغییر وضعیت از `S` به `S'` است.

مسئله به اثبات موارد زیر کاهش می‌یابد:

- ردیف اجرای _درست_ است.
  - هر opcode به درستی طبق مشخصات کاغذ زرد اتریوم اجرا شده است.
    - به عنوان مثال، opcode `ADD` باید منجر به خارج کردن دو مقدار از پشته و اضافه کردن جمع آنها به پشته شود.
    - یک اثبات باید نشان دهد که هر opcode با رفتار صحیحی اجرا شده است، از جمله هرگونه تغییر در داده‌های موقت (پشته و حافظه) یا داده‌های پایدار (کد بایت و ذخیره‌سازی قرارداد).
  - لیست مرتب opcodes در حال اجرا در واقع لیست صحیح opcodes است که توسط تراکنش تحریک شده است.
    - این شامل بارگذاری صحیح کد اولیه تراکنش و کد بایت برای هر قرارداد فراخوانی شده است.
- ردیف اجرای با وضعیت اولیه `S` شروع می‌شود و به وضعیت `S'` منتهی می‌شود.

<ClickToZoom src={zkevm3} />

در بخش‌های بعدی، ما به جزئیات نحوه اثبات صحت ردیف‌های اجرای EVM خواهیم پرداخت.

## بیشتر بیاموزید

- [فصل GitBook](https://cypherpunks-core.github.io/ethereumbook/13evm.html) از Cypherpunks درباره EVM
- [بررسی اجمالی zkEVM](https://youtu.be/NHwd-gJ8xg4) - هایچن شِن