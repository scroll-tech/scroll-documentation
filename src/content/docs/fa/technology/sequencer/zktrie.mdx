---
section: technology
date: Last Modified
title: "zkTrie"
lang: "fa"
permalink: "technology/sequencer/zktrie"
whatsnext: { "مقدمه ای بر zkEVM": "/fa/technology/zkevm/intro-to-zkevm/" }
excerpt: "zkTrie یک درخت مرکل پاتریشیا باینری نازک ساخته شده با هش پوزیدون است."
---

import Aside from "../../../../../components/Aside.astro"
import ClickToZoom from "../../../../../components/ClickToZoom.astro"
import zktrie1 from "../_images/zktrie-arch.png"
import zktrie2 from "../_images/zktrie-insertion.png"
import zktrie3 from "../_images/zktrie-deletion.png"

این سند به بررسی zkTrie می‌پردازد، که یک درخت مرکل پاتریشیا باینری نازک است و برای ذخیره‌ی مؤثر جفت‌های کلید-مقدار استفاده می‌شود. این سند ساختار درخت، ساخت، هش گره‌ها و عملیات‌های درخت، از جمله درج و حذف را توضیح می‌دهد.

شما می‌توانید به [مخزن zktrie](https://github.com/scroll-tech/zktrie) نیز مراجعه کنید.

## ساختار درخت

zkTrie یک درخت مرکل پاتریشیا باینری نازک است که در شکل زیر به تصویر کشیده شده است.
قبل از بررسی دقیق درخت مرکل پاتریشیا نازک، بیایید به طور مختصر به درختان مرکل و پاتریشیا بپردازیم.
* **درخت مرکل**: درختی است که در آن هر برگ نشان‌دهنده‌ی هش یک بلوک داده است و هر گره غیر برگ نشان‌دهنده‌ی هش گره‌های فرزند خود است.
* **درخت پاتریشیا**: نوعی درخت رادیکس یا درخت فشرده است که برای ذخیره‌ی مؤثر جفت‌های کلید-مقدار استفاده می‌شود. این درخت گره‌های با پیشوند یکسان را برای اشتراک مسیر مشترک رمزگذاری می‌کند، که مسیر با توجه به مقدار کلید گره تعیین می‌شود.

همانطور که در شکل ۱ نشان داده شده است، در zkTrie سه نوع گره وجود دارد:
- **گره شاخه**: از آنجا که zkTrie یک درخت باینری است، گره شاخه دارای دو فرزند است.
- **گره برگ**: یک گره برگ داده‌های یک جفت کلید-مقدار را در خود نگه می‌دارد.
- **گره خالی**: یک نوع خاص از گره است که نشان‌دهنده‌ی زیر درختی است که پیشوند مشترک دارد و خالی است.

در zkTrie، ما از هش پوزیدون برای محاسبه‌ی هش گره استفاده می‌کنیم، زیرا این روش برای اثبات در مدار zk کارآمدتر و مناسب‌تر است.

<ClickToZoom src={zktrie1} alt="ساختار zkTrie" caption="شکل ۱. ساختار zkTrie" />

## ساخت درخت

برای یک جفت کلید-مقدار، ابتدا یک *کلید امن* برای گره برگ مربوطه با استفاده از تابع هش پوزیدون محاسبه می‌کنیم. این کار باعث می‌شود که کلید به طور یکنواخت در فضای کلید توزیع شود. روش هش گره‌ها در بخش [هش گره](#node-hashing) توضیح داده شده است.

مسیر گره برگ جدید را با عبور از کلید امن از کم‌اهمیت‌ترین بیت (LSB) تا مهم‌ترین بیت (MSB) رمزگذاری می‌کنیم. در هر مرحله، اگر بیت ۰ باشد، به فرزند چپ حرکت می‌کنیم؛ در غیر این صورت، به فرزند راست حرکت می‌کنیم.

ما حداکثر عمق zkTrie را به ۲۴۸ محدود می‌کنیم، به این معنی که درخت تنها از بیت‌های پایین‌تر ۲۴۸ کلید عبور می‌کند. زیرا فضای کلید امن یک میدان محدود است که توسط هش پوزیدون استفاده می‌شود و تمام محدوده $2^{256}$ را اشغال نمی‌کند، نمایه بیت کلید می‌تواند مبهم باشد و بنابراین باعث مشکل صحت در مدار zk می‌شود. پس از اینکه کلید را به ۲۴۸ بیت پایین‌تر برش می‌دهیم، فضای کلید می‌تواند به طور کامل محدوده $2^{248}$ را اشغال کند و در نمایه بیت مبهم نباشد.

ما یک بهینه‌سازی برای کاهش عمق درخت با فشرده‌سازی زیر درختی که تنها یک گره برگ دارد به یک گره برگ واحد انجام می‌دهیم. به عنوان مثال، در شکل ۱، درخت در مجموع سه گره دارد، با کلیدهای `0100`، `0010` و `1010`. زیرا تنها یک گره با کلید `00` وجود دارد، گره برگ برای کلید `0100` فقط پیشوند `00` را طی می‌کند و به طور کامل گسترش نمی‌یابد که منجر به عمق ۴ شود.

## عملیات‌های درخت

### درج

<ClickToZoom src={zktrie2} alt="درج یک گره برگ جدید به zkTrie" caption="شکل ۲. درج یک گره برگ جدید به zkTrie" />

هنگامی که یک گره برگ جدید به zkTrie اضافه می‌شود، دو حالت وجود دارد که در شکل ۲ نشان داده شده است.

1. هنگامی که در مسیر کلید گره عبور می‌کنیم و به یک گره خالی می‌رسیم (شکل ۲الف). در این حالت، تنها کافی است که این گره خالی را با گره برگ جایگزین کنیم و مسیر را تا ریشه به‌روزرسانی کنیم.
2. هنگامی که در مسیر کلید گره عبور می‌کنیم و به گره برگ دیگری `b` می‌رسیم (شکل ۲ب). در این حالت، باید گره برگ موجود `b` را به پایین فشار دهیم تا زمانی که بیت‌های کلیدهای دو گره برگ متفاوت شوند. در هر مرحله فشردن به پایین، باید یک گره خالی خواهر در گره شاخه اضافه کنیم. هنگامی که به سطحی می‌رسیم که بیت‌ها تفاوت دارند، سپس دو گره برگ `b` و `d` را به عنوان فرزند چپ و راست با توجه به بیت‌های آنها قرار می‌دهیم. در آخر، مسیر را به عقب می‌رویم و هش مرکل همه گره‌های شاخه را به‌روزرسانی می‌کنیم.

### حذف

<ClickToZoom src={zktrie3} alt="حذف یک گره برگ از zkTrie" caption="شکل ۳. حذف یک گره برگ از zkTrie" />

حذف یک گره برگ مشابه درج است. دو حالت وجود دارد که در شکل ۳ نشان داده شده است.

1. خواهر گره برگ که باید حذف شود یک گره شاخه است (شکل ۳الف). در این حالت، می‌توانیم به سادگی گره `a` را با یک گره خالی جایگزین کنیم و هش گره‌های والدین آن را تا ریشه به‌روزرسانی کنیم.
2. خواهر گره برگ که باید حذف شود یک گره برگ است (شکل ۳ب). مشابه به حالت ۱، ابتدا گره برگ را با گره خالی جایگزین می‌کنیم و شروع به فشرده‌سازی گره خواهر به سمت بالا می‌کنیم تا زمانی که گره خواهر دیگر گره خالی نباشد. برای مثال، در شکل ۳ب، ما گره برگ `b` را با گره خالی جایگزین می‌کنیم. زیرا خواهر گره `c` اکنون تبدیل به گره خالی شده است، باید گره `c` را یک سطح به سمت بالا حرکت داده و والدین آن را جایگزین کنیم. خواهر جدید گره `c`، گره `e`، هنوز گره خالی است. بنابراین دوباره گره `c` را به سمت بالا حرکت می‌دهیم. اکنون که خواهر گره `c`، گره `a`، یک گره برگ است، فرآیند حذف تمام شده است.

توجه داشته باشید که خواهر یک گره برگ در zkTrie معتبر نمی‌تواند یک گره خالی باشد. در غیر این صورت، باید همیشه زیر درخت را هرس کرده و گره برگ را به سمت بالا حرکت دهیم.

## هش گره‌ها

در این بخش، نحوه محاسبه کلید امن برگ و هش مرکل گره را توضیح خواهیم داد. ما از هش پوزیدون با ارایت ۲ برای هر دو محاسبات هش استفاده می‌کنیم. در Scroll، تابع هش پوزیدون به گونه‌ای تنظیم شده است که هر بار دو ورودی عنصر میدان و یک `domain_value` به عنوان زمینه اولیه برای تفکیک دامنه را دریافت کند، به صورت زیر:
```
h{domain_value}(input1, input2)
```

### گره خالی

هش گره یک گره خالی برابر با ۰ است.

### گره شاخه

هش گره شاخه به صورت زیر محاسبه می‌شود:

```go
branchNodeHash = h{BranchNodeType}(leftChildHash, rightChildHash)
```

### گره برگ

هش گره برگ به صورت زیر

 محاسبه می‌شود.

```go
leafNodeHash = h{LeafNodeType}(nodeKey, valueHash)
```

این محاسبه شامل دو میدان `nodeKey` و `valueHash` است.
- `nodeKey` از کلید اصلی هش شده است. مقدار دامنه‌ای که در هش پوزیدون استفاده می‌شود ۲۵۶ است.
- `valueHash` با هش کردن مقدار گره برگ محاسبه می‌شود. مقدار دامنه‌ای که در هش پوزیدون استفاده می‌شود `256 * n` است، که `n` تعداد عناصر در مقدار گره برگ است.

دو نوع گره برگ وجود دارد: حساب‌های اتریوم و جفت‌های کلید-مقدار ذخیره‌سازی. در ادامه، روش محاسبه کلید گره و هش مقدار برای هر نوع گره برگ به طور جداگانه توضیح داده شده است.

#### گره برگ حساب اتریوم

یک گره برگ حساب اتریوم شامل یک آدرس اتریوم و یک ساختار داده‌ای حساب است. کلید امن از آدرس اتریوم استخراج می‌شود.
```go
var address byte[20] // ۲۰ بایت در big-endian
valHi := address[0:16]
valLo := address[16:20] * 2^96 // افزودن ۱۲ بایت ۰ در انتها
nodeKey := h{512}(valHi, valLo)
```

یک ساختار داده‌ای حساب در Scroll شامل فیلدهای زیر است (فرم نشان‌دهنده مقدار میدان و یک مقدار ۲۵۴ بیتی است):

- `Nonce`: u64
- `Balance`: u256، اما به عنوان Fr در نظر گرفته می‌شود
- `StorageRoot`: Fr
- `KeccakCodeHash`: u256
- `PoseidonCodeHash`: Fr
- `CodeSize`: u64

قبل از محاسبه هش مقدار، ساختار داده‌ای حساب به لیستی از مقادیر `u256` تبدیل می‌شود. طرح مارشالینگ به صورت زیر است:

```text
(طرح به ترتیب big-endian)
[0:32]
	[0:16] رزرو شده با تمام ۰
	[16:24] CodeSize، uint64 در big-endian
	[24:32] Nonce، uint64 در big-endian
[32:64] Balance
[64:96] StorageRoot
[96:128] KeccakCodeHash
[128:160] PoseidonCodehash
(مجموع ۱۶۰ بایت)
```

تابع مارشالینگ همچنین یک مقدار `flag` را همراه با یک وکتور از مقادیر `u256` بازمی‌گرداند. مقدار `flag` یک بیت‌مپ است که نشان‌دهنده این است که آیا یک مقدار `u256` نمی‌تواند به عنوان عنصر میدان (Fr) در نظر گرفته شود. مقدار `flag` برای حساب‌های دولتی ۸ است، به شرح زیر:

```
         +--------------------+---------+------+----------+----------+
 index   |          0         |    1    |   2  |     3    |     4    |
         +--------------------+---------+------+----------+----------+
  u256   | nonce||codesize||0 | balance | root |  keccak  | poseidon |
         +--------------------+---------+------+----------+----------+
flag bit |          0         |    0    |   0  |     1    |     0    |
         +--------------------+---------+------+----------+----------+
         (LSB)                                                   (MSB)
```

هش مقدار در دو مرحله محاسبه می‌شود:
1. تبدیل مقدارهایی که نمی‌توانند به عنوان عنصر میدان هش پوزیدون در نظر گرفته شوند به عنصر میدان.
2. ترکیب عناصر میدان در یک ساختار درخت باینری تا ریشه درخت به عنوان هش مقدار در نظر گرفته شود.

در مرحله اول، زمانی که بیت در `flag` ۱ است که نشان‌دهنده مقدار `u256` است که نمی‌تواند به عنوان عنصر میدان در نظر گرفته شود، مقدار را به یک مقدار بالایی ۱۲۸ بیتی و یک مقدار پایینی ۱۲۸ بیتی تقسیم می‌کنیم و سپس آنها را به هش پوزیدون می‌دهیم تا یک مقدار عنصر میدان به دست آوریم، `h(valueHi, valueLo)`.

```go
// تبدیل Keccak codehash به یک عنصر میدان
compressedKeccakCodeHash := h{512}(keccakCodeHash[0:16], keccakCodeHash[16:32])
```

دوم، هش مقدار به صورت زیر محاسبه می‌شود:

```go
domain := 256 * 5  // ۵ عنصر برای محاسبه valueHash
valueHash :=
    h{domain}(
        h{domain}(
            h{domain}(nonce||codesize||0, balance),
            h{domain}(
                storageRoot,
                compressedKeccakCodeHash,
            ),
        ),
        poseidonCodeHash,
    )
```

#### گره برگ ذخیره‌سازی

یک گره برگ ذخیره‌سازی جفتی از کلید-مقدار را رمزگذاری می‌کند که هر دو کلید و مقدار مقادیر `u256` هستند. کلید امن این گره برگ از کلید ذخیره‌سازی استخراج می‌شود.

```go
var storageKey byte[32]  // ۳۲ بایت در big-endian
valHi := storageKey[0:16]
valLo := storageKey[16:32]
nodeKey := h{512}(valHi, valLo)
```

مقدار ذخیره‌سازی یک مقدار `u256` است. مقدار `flag` برای مقدار ذخیره‌سازی ۱ است، به شرح زیر:

```
         +--------------+
  index  |      0       |
         +--------------+
  u256   | storageValue |
         +--------------+
flag bit |      1       |
         +--------------+
```

هش مقدار به صورت زیر محاسبه می‌شود:

```go
valueHash = h{512}(storageValue[0:16], storageValue[16:32])
```