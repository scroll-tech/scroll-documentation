---
section: technology
date: Last Modified
title: "فرآیند رول‌آپ"
lang: "fa"
permalink: "technology/chain/rollup"
whatsnext: { "تفاوت‌های EVM با Ethereum": "/fa/technology/chain/differences/" }
---

import ClickToZoom from "../../../../../components/ClickToZoom.astro"
import RollupProcess from "../_images/rollup.png"
import { Tabs } from "../../../../../components/Tabs/Tabs.tsx"

این سند فرآیند رول‌آپ در Scroll را توصیف می‌کند.

## روند کار

<ClickToZoom src={RollupProcess} alt="فرآیند رول‌آپ" />

شکل، روند کار رول‌آپ را نشان می‌دهد. توالی‌کننده L2 شامل سه ماژول است:

- **خدمات هماهنگ‌سازی** به رویدادهای صادر شده از قرارداد پل L1 مشترک می‌شود. به محض اینکه رویدادهای جدیدی به صندوق ورودی L1 اضافه می‌شود، خدمات هماهنگ‌سازی یک تراکنش جدید `L1MessageTx` ایجاد کرده و آن را به صف تراکنش‌های محلی L1 اضافه می‌کند.
- **Mempool** تراکنش‌هایی را که به طور مستقیم به توالی‌کننده L2 ارسال می‌شود، جمع‌آوری می‌کند.
- **اجراکننده** تراکنش‌ها را از هر دو صف تراکنش L1 و Mempool L2 کش می‌آورد و آنها را اجرا می‌کند تا یک بلوک جدید L2 را بسازد.

گره رول‌آپ شامل سه ماژول است:

- **انتقال‌دهنده** تراکنش‌های تأیید و نهایی‌سازی را به قرارداد رول‌آپ برای دسترسی به داده‌ها و نهایی‌سازی ارسال می‌کند.
- **پیشنهاددهنده بخش** و **پیشنهاددهنده دسته** بخش‌ها و دسته‌های جدید را با توجه به محدودیت‌های توصیف شده در [تجمع تراکنش‌ها](/technology/chain/transactions#transaction-batching) پیشنهاد می‌دهند.

فرآیند رول‌آپ را می‌توان به سه مرحله تقسیم کرد: اجرای تراکنش، تجمع و تعهد داده، و تولید و نهایی‌سازی اثبات.

### مرحله 1. اجرای تراکنش

1. کاربران تراکنش‌ها را به قرارداد پل L1 یا توالی‌کننده‌های L2 ارسال می‌کنند.
2. خدمات هماهنگ‌سازی در توالی‌کننده L2 جدیدترین تراکنش‌های اضافه شده به L1 را از قرارداد پل دریافت می‌کند.
3. توالی‌کننده L2 تراکنش‌ها را از هر دو صف پیام L1 و Mempool L2 پردازش کرده و بلوک‌های L2 را می‌سازد.

### مرحله 2. تجمع و تعهد داده

4. گره رول‌آپ جدیدترین بلوک‌های L2 را نظارت کرده و داده‌های تراکنش را دریافت می‌کند.
5. اگر معیارهای (توصیف شده در [تجمع تراکنش‌ها](/technology/chain/transactions#transaction-batching)) برآورده شود، گره رول‌آپ یک بخش یا دسته جدید پیشنهاد می‌دهد و آن را در پایگاه داده ثبت می‌کند. در غیر این صورت، گره رول‌آپ منتظر بلوک‌ها یا بخش‌های بیشتری می‌ماند.
6. پس از ایجاد یک دسته جدید، انتقال‌دهنده رول‌آپ داده‌های تراکنش‌های این دسته را جمع‌آوری کرده و یک تراکنش تأیید به قرارداد رول‌آپ برای دسترسی به داده‌ها ارسال می‌کند.

### مرحله 3. تولید و نهایی‌سازی اثبات

7. هنگامی که هماهنگ‌کننده یک بخش یا دسته جدید از پایگاه داده بررسی می‌کند:
   - در مورد یک بخش جدید، هماهنگ‌کننده از توالی‌کننده L2 برای همه بلوک‌های این بخش، ردپای اجرای آنها را جستجو کرده و سپس یک وظیفه اثبات بخش را به یک اثبات‌کننده zkEVM به طور تصادفی انتخاب شده ارسال می‌کند.
   - در مورد یک دسته جدید، هماهنگ‌کننده اثبات‌های بخش همه بخش‌های این دسته را از پایگاه داده جمع‌آوری کرده و یک وظیفه اثبات دسته را به یک اثبات‌کننده تجمیع‌کننده به طور تصادفی انتخاب شده ارسال می‌کند.
8. هنگامی که هماهنگ‌کننده اثبات‌های بخش یا دسته را از اثبات‌کننده دریافت می‌کند، آن را به پایگاه داده می‌نویسد.
9. هنگامی که انتقال‌دهنده رول‌آپ یک اثبات دسته جدید از پایگاه داده بررسی می‌کند، یک تراکنش نهایی‌سازی به قرارداد رول‌آپ برای تأیید اثبات ارسال می‌کند.

## تراکنش تأیید

تراکنش تأیید اطلاعات بلوک و داده‌های تراکنش‌ها را به L1 برای دسترسی به داده‌ها ارسال می‌کند. این تراکنش شامل هدر دسته والد، داده‌های بخش و یک نقشه بیت از پیام‌های L1 رد شده است. هدر دسته والد نشان‌دهنده دسته قبلی است که این دسته به آن پیوند دارد. دسته والد باید قبلاً تأیید شده باشد؛ در غیر این صورت، تراکنش برگشت داده خواهد شد. در زیر امضای تابع `commitBatch` آمده است.

```solidity
function commitBatch(
    uint8 version,
    bytes calldata parentBatchHeader,
    bytes[] memory chunks,
    bytes calldata skippedL1MessageBitmap
) external override OnlySequencer
```

پس از اینکه تابع `commitBatch` تأیید کرد که دسته والد قبلاً تأیید شده است، هدر دسته جدید را می‌سازد و هش هدر دسته را در قرارداد `ScrollChain` ذخیره می‌کند.

```solidity
mapping(uint256 => bytes32) public committedBatches;
```

کدگذاری هدر دسته و داده‌های بخش در بخش [Codec](#codec) توصیف شده است. بیشتر فیلدهای هدر دسته به سادگی از داده‌های بخش استنتاج می‌شوند. یک فیلد مهم که باید به آن توجه کرد `dataHash` است که بخشی از ورودی عمومی برای تأیید اعتبار اثبات خواهد بود. فرض کنید که یک دسته شامل `n` بخش است، `dataHash` آن به شرح زیر محاسبه می‌شود

```
batch.dataHash := keccak(chunk[0].dataHash || ... || chunk[n-1].dataHash)
```

فرض کنید که یک بخش شامل `k` بلوک است، `dataHash` آن به شرح زیر محاسبه می‌شود

```
chunk.dataHash := keccak(blockContext[0] || ... || blockContext[k-1] ||
                         block[0].l1TxHashes || block[0].l2TxHashes || ... ||
                         block[k-1].l1TxHashes || block[k-1].l2TxHashes)
```

که در آن `block.l1TxHashes` هش‌های تراکنش‌های L1 در این بلوک هستند و `block.l2TxHashes` هش‌های تراکنش‌های L2 در این بلوک هستند. توجه داشته باشید که هش‌های تراکنش‌های L1 توسط گره رول‌آپ بارگذاری نمی‌شود، بلکه مستقیماً از قرارداد `L1MessageQueue` با توجه به محدوده شاخص پیام‌های L1 گنجانده شده در این بلوک بارگذاری می‌شود. هش‌های تراکنش‌های L2 از بایت‌های کدگذاری شده RLP در فیلد `l2Transactions` در [بخش](#Chunk-Codec) محاسبه می‌شود.

علاوه بر این، تابع `commitBatch` شامل یک نقشه بیت از پیام‌های L1 رد شده است. متأسفانه، این به دلیل مشکل سرریز اثبات است. اگر تراکنش L1 مربوط به یک پیام L1 از محدودیت ظرفیت مدار فراتر برود، نمی‌توانیم اثبات معتبری برای این تراکنش تولید کنیم و بنابراین نمی‌توانیم آن را در L1 نهایی کنیم. Scroll به طور فعال در حال کار برای حذف مشکل سرریز اثبات از طریق به‌روزرسانی‌های سیستم اثبات ما است.

## تراکنش نهایی‌سازی

تراکنش نهایی‌سازی دسته‌ای که قبلاً تأیید شده را با یک اثبات اعتبار نهایی می‌کند. این تراکنش همچنین ریشه وضعیت و ریشه برداشت بعد از دسته را ارسال می‌کند. در زیر امضای تابع `finalizeBatchWithProof` آمده است:

```solidity
function finalizeBatchWithProof(
    bytes calldata batchHeader,
    bytes32 prevStateRoot,
    bytes32 postStateRoot,
    bytes32 withdrawRoot,
    bytes calldata aggrProof
) external override OnlyProver
```

تابع `finalizeBatchWithProof` ابتدا بررسی می‌کند که آیا دسته در قرارداد تأیید شده است. سپس ورودی عمومی را به شرح زیر محاسبه می‌کند

```
publicInputHash := keccak(chainId || prevStateRoot || postStateRoot || withdrawRoot || batch.dataHash)
```

هش ورودی عمومی و اثبات اعتبار به تأییدکننده plonk solidity ارسال می‌شود. هنگامی که تأیید موفقیت‌آمیز است، ریشه وضعیت و ریشه برداشت جدید در قرارداد `ScrollChain` ذخیره می‌شود.

```solidity
mapping(uint256 => bytes32) public override finalizedStateRoots;
mapping(uint256 => bytes32) public override withdrawRoots;
```

در این مرحله، ریشه وضعیت جدیدترین دسته نهایی‌شده می‌تواند به صورت قابل اعتماد استفاده شود و تراکنش‌های برداشت در آن دسته می‌توانند با استفاده از اثبات مرکل به ریشه برداشت، بر روی L1 اجرا شوند.

## Codec

این بخش Codec سه ساختار داده‌ای در قرارداد رول‌آپ: `BatchHeader`، `Chunk` و `BlockContext` را توصیف می‌کند.

آخرین به‌روزرسانی به Codec در [ارتقاء برنولی](/technology/overview/scroll-upgrades#bernoulli-upgrade) معرفی شد.

<Tabs sharedStore="upgrades" client:visible>
<Fragment slot="tab.bernoulli">برنولی</Fragment>
<Fragment slot="tab.archimedes">آرشمیدس</Fragment>
  <Fragment slot="panel.bernoulli">
    <slot name="bernoulli" />

    این فرمت داده‌ای پس از ارتقاء کوری، همچنان قابل اجرا است و تغییری نکرده است.

    #### Codec `BatchHeader`

    | فیلد                    | بایت‌ها | نوع        | آفست | توضیحات                                                     |
    | ------------------------ | ------- | ----------- | ------ | --------------------------------------------------------------- |
    | `version`                | 1       | `uint8`     | 0      | نسخه هدر دسته                                               |
    | `batchIndex`             | 8       | `uint64`    | 1      | ایندکس دسته                                                  |
    | `l1MessagePopped`        | 8       | `uint64`    | 9      | تعداد پیام‌های L1 که در دسته قرار گرفته‌اند                  |
    | `totalL1MessagePopped`   | 8       | `uint64`    | 17     | تعداد کل پیام‌های L1 که بعد از دسته قرار گرفته‌اند          |
    | `dataHash`               | 32      | `bytes32`   | 25     | هش داده‌های دسته                                             |
    | `blobVersionedHash`      | 32      | `bytes32`   | 57     | هش نسخه‌دار blob با داده‌های این دسته                          |
    | `parentBatchHash`        | 32      | `bytes32`   | 89     | هش دسته والد                                                 |
    | `skippedL1MessageBitmap` | دینامیک | `uint256[]` | 121    | نقشه بیت برای نشان دادن پیام‌های L1 که در دسته نادیده گرفته شده‌اند |

    #### Codec `Chunk`

    | فیلد            | بایت‌ها | نوع           | آفست    | توضیحات                                                                                                                                       |
    | ---------------- | ------- | -------------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `numBlocks`      | 1       | `uint8`        | 0         | تعداد بلوک‌ها در بخش                                                                                                                 |
    | `block[0]`       | 60      | `BlockContext` | 1         | اطلاعات بلوک 1م                                                                                                            |
    | ...              | ...     | ...            | ...       | ...                                                                                                                                               |
    | `block[i]`       | 60      | `BlockContext` | `60*i+1`  | اطلاعات بلوک `i+1`ام                                                                                                           |
    | ...              | ...     | ...            | ...       | ...                                                                                                                                               |
    | `block[n-1]`     | 60      | `BlockContext` | `60*n-59` | اطلاعات بلوک آخر                                                                                                           |

    #### Codec `BlockContext`

    | فیلد             | بایت‌ها | نوع      | آفست | توضیحات                                                                         |
    | ----------------- | ----- | --------- | ------ | ----------------------------------------------------------------------------------- |
    | `blockNumber`     | 8     | `uint64`  | 0      | شماره بلوک                                                                    |
    | `timestamp`       | 8     | `uint64`  | 8      | زمان بلوک                                                                      |
    | `baseFee`         | 32    | `uint256` | 16     | هزینه پایه این بلوک. در حال حاضر همیشه 0 است، زیرا EIP-1559 غیرفعال است. |
    | `gasLimit`        | 8     | `uint64`  | 48     | محدودیت گس این بلوک                                                         |
    | `numTransactions` | 2     | `uint16`  | 56     | تعداد تراکنش‌ها در این بلوک، شامل تراکنش‌های L1 و L2                |
    | `numL1Messages`   | 2     | `uint16`  | 58     | تعداد پیام‌های L1 در این بلوک    

  </Fragment>

  <Fragment slot="panel.archimedes">
    <slot name="archimedes" />
    #### Codec `BatchHeader`

    | فیلد                    | بایت‌ها | نوع        | آفست | توضیحات                                                     |
    | ------------------------ | ------- | ----------- | ------ | --------------------------------------------------------------- |
    | `version`                | 1       | `uint8`     | 0      | نسخه هدر دسته                                               |
    | `batchIndex`             | 8       | `uint64`    | 1      | ایندکس دسته                                                  |
    | `l1MessagePopped`        | 8       | `uint64`    | 9      | تعداد پیام‌های L1 که در دسته قرار گرفته‌اند                  |
    | `totalL1MessagePopped`   | 8       | `uint64`    | 17     | تعداد کل پیام‌های L1 که بعد از دسته قرار گرفته‌اند          |
    | `dataHash`               | 32      | `bytes32`   | 25     | هش داده‌های دسته                                             |
    | `parentBatchHash`        | 32      | `bytes32`   | 57     | هش دسته والد                                                 |
    | `skippedL1MessageBitmap` | دینامیک | `uint256[]` | 89     | نقشه بیت برای نشان دادن پیام‌های L1 که در دسته نادیده گرفته شده‌اند |

    #### Codec `Chunk`

    | فیلد            | بایت‌ها | نوع           | آفست    | توضیحات                                                                                                                                       |
    | ---------------- | ------- | -------------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `numBlocks`      | 1       | `uint8`        | 0         | تعداد بلوک‌ها در بخش                                                                                                                 |
    | `block[0]`       | 60      | `BlockContext` | 1         | اطلاعات بلوک 1م                                                                                                            |
    | ...              | ...     | ...            | ...       | ...                                                                                                                                               |
    | `block[i]`       | 60      | `BlockContext` | `60*i+1`  | اطلاعات بلوک `i+1`ام                                                                                                           |
    | ...              | ...     | ...            | ...       | ...                                                                                                                                               |
    | `block[n-1]`     | 60      | `BlockContext` | `60*n-59` | اطلاعات بلوک آخر                                                                                                           |
    | `l2Transactions` | دینامیک | `bytes`        | `60*n+1`  | کدگذاری شده RLP تراکنش‌های L2 با امضاها. طول بایت (`uint32`) کدگذاری RLP قبل از هر تراکنش درج شده است. |                                                                                                         |

    #### Codec `BlockContext`

    | فیلد             | بایت‌ها | نوع      | آفست | توضیحات                                                                         |
    | ----------------- | ----- | --------- | ------ | ----------------------------------------------------------------------------------- |
    | `blockNumber`     | 8     | `uint64`  | 0      | شماره بلوک                                                                    |
    | `timestamp`       | 8     | `uint64`  | 8      | زمان بلوک                                                                      |
    | `baseFee`         | 32    | `uint256` | 16     | هزینه پایه این بلوک. در حال حاضر همیشه 0 است، زیرا EIP-1559 غیرفعال است. |
    | `gasLimit`        | 8     | `uint64`  | 48     | محدودیت گس این بلوک                                                         |
    | `numTransactions` | 2     | `uint16`  | 56     | تعداد تراکنش‌ها در این بلوک، شامل تراکنش‌های L1 و L2                |
    | `numL1Messages`   | 2     | `uint16`  | 58     | تعداد پیام‌های L1 در این بلوک    

  </Fragment>
</Tabs>